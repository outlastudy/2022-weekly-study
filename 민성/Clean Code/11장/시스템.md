### 도시를 세운다면

여러분이 도시를 세운다면 온갖 세세한 사항을 혼자서 직접 관리할 수 있을까?  
아마도 불가능하다. 이미 세워진 도시라도 한 사람의 힘으로는 무리다.  
그럼에도 도시는 잘 돌아간다.  
적절한 ***추상화*** 와 ***모듈화*** 때문, 큰 그림을 이해하지 못하더라도 개인과 개인이 관리하는 ***구성요소*** 는 효율적으로 돌아간다.  
흔히 소프트웨어팀도 도시처럼 구성한다.


### 시스템 제작과 시스템 사용을 분리하라

***우선 제작은 사용과 아주 다르다는 사실을 명심한다.***

소프트웨어 시스템은 (애플리케이션객체를 제작하고 의존성을 서로 '연결'하는)준비 과정과 (준비 과정 이후에 이어지는)런타임 로직을 분리해야 한다.  

시작 단계는 모든 애플리케이션이 풀어야 할 ***관심사*** 다.  
***관심사의 분리*** 란? 특정한 관심사에 따라 기능을 나누고, 각 기능을 독립적으로 개발한 뒤 이를 조합하는 방식  

```java
public Service getService() {
	if (service == null)
		service = new MyServiceImpl(...); // 모든 상황에 적합한 기본값일까?
	return service;
}
```
위의 코드는 초기화 지연 혹은 계산 지연이라는 기법으로 준비 과정과 런타임 로직이 마구 뒤섞인 전형적인 예다.  
- 장점
	1. 실제로 필요할 때까지 객체를 생성하지 않으므로 불필요한 부화가 걸리지 않는다.  
	-> 따라서 애플리케이션이 시작하는 시간이 그만큼 빨라진다.
	2. 어떤 경우에도 null포인터를 반환하지 않는다. 

- 단점
	1. getService 메서드가 MyServiceImpl에 명시적으로 의존한다.  
	-> 런타임 로직에서 MyServiceImpl 객체를 전혀 사용하지 않더라도 의존성을 해결하지 않으면 컴파일이 안된다.
	2. MyServiceImpl이 무거운 객체라면 단위 테스트에서 getService 메서드를 호출하기 전에 적절한 테스트 전용 객체를 service 필드에 할당해야 한다.
	3. 일반 런타임 로직에 객체 생성 로직을 섞어놓은 탓에 모든 실행 경로도 테스트해야 한다.
	4. 책임이 둘이라는 말은 메서드가 작업을 두 가지 이상 수행한다는 의미로 ***단일 책임 원칙*** 을 깨고 있다.

한번 정도의 사용은 심각한 문제가 아니지만 많은 애플리케이션이 이처럼 좀스러운 설정 기법을 수시로 사용한다.

#
